{"code": "\nimport configargparse\nimport json\nimport logging\nimport math\nimport typing\n\nfrom sky_spot.strategies.multi_strategy import MultiRegionStrategy\nfrom sky_spot.utils import ClusterType\n\nif typing.TYPE_CHECKING:\n    from sky_spot import env, task\n\nlogger = logging.getLogger(__name__)\n\nclass EvolutionaryStrategy(MultiRegionStrategy):\n    \"\"\"\n    A robust, stateful, and well-structured strategy for multi-region environments.\n    This initial program serves as a strong and safe starting point for evolution.\n    It correctly handles the object lifecycle, provides a basic caching mechanism,\n    and implements a sound, urgency-based heuristic.\n    \"\"\"\n    NAME = 'evolutionary_robust_starter'\n\n    def __init__(self, args: configargparse.Namespace):\n        super().__init__(args)\n        # --- Framework Lifecycle Note ---\n        # `self.env` and `self.task` are NOT available in `__init__`.\n        # They are initialized later by the framework via the `reset()` method.\n        # Therefore, any attributes that depend on them must be initialized here\n        # as None or empty, and populated in `reset()`.\n\n        # --- State Variables ---\n        self.initialized: bool = False\n        self.region_cache: typing.Dict[int, typing.Dict[str, typing.Any]] = {}\n        self.next_exploration_target_idx: int = 0\n\n    def reset(self, env: 'env.Env', task: 'task.Task'):\n        \"\"\"Called by the framework to initialize environment-dependent state.\"\"\"\n        super().reset(env, task)\n        # Initialize the cache for all known regions\n        for i in range(self.env.get_num_regions()):\n            self.region_cache[i] = {'has_spot': None, 'last_checked': -1}\n        self.initialized = True\n        logger.info(f\"{self.NAME} strategy has been reset and initialized.\")\n\n    def _is_behind_schedule(self) -> bool:\n        \"\"\"\n        Calculates if current progress is behind the required linear schedule.\n        Returns True if behind, False if on-track or ahead.\n        \"\"\"\n        if not self.initialized:\n            # Should not happen in a normal run, but a safeguard.\n            return False\n\n        c_0 = self.task_duration\n        c_t = self.task_duration - sum(self.task_done_time)\n        t = self.env.elapsed_seconds\n        r_0 = self.deadline\n\n        if r_0 <= t:\n            return True\n        if t == 0:\n            return False\n\n        # Required progress assuming a linear work completion schedule.\n        required_progress = t * (c_0 / r_0)\n        actual_progress = c_0 - c_t\n\n        return actual_progress < required_progress\n\n    def _step(self, last_cluster_type: ClusterType, has_spot: bool) -> ClusterType:\n        \"\"\"\n        Main decision logic for the strategy.\n        \"\"\"\n        if not self.initialized or self.task_done:\n            return ClusterType.NONE\n\n        current_region_idx = self.env.get_current_region()\n        num_regions = self.env.get_num_regions()\n\n\n        # Update cache with the latest information for the current region\n        self.region_cache[current_region_idx]['has_spot'] = has_spot\n        self.region_cache[current_region_idx]['last_checked'] = self.env.elapsed_seconds\n\n        # --- Decision Logic ---\n        if self._is_behind_schedule():\n            # URGENT: We are behind schedule. Prioritize getting work done.\n            if has_spot:\n                return ClusterType.SPOT\n            else:\n                # No spot here. We must use ON_DEMAND to avoid falling further behind.\n                return ClusterType.ON_DEMAND\n        else:\n            # NOT URGENT: We are ahead of schedule. We can prioritize cost savings.\n            if has_spot:\n                # Spot is available here, use it.\n                return ClusterType.SPOT\n            else:\n                # No spot here. Let's explore. Instead of just cycling, a smarter\n                # evolution could use the cache to find a promising region.\n                self.next_exploration_target_idx = (current_region_idx + 1) % num_regions\n                self.env.switch_region(self.next_exploration_target_idx)\n                return ClusterType.NONE\n"}